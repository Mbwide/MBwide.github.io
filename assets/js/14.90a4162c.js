(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{498:function(t,r,_){t.exports=_.p+"assets/img/cunChuLeiBianLiang.2ede9961.png"},527:function(t,r,_){"use strict";_.r(r);var s=_(4),v=Object(s.a)({},(function(){var t=this,r=t.$createElement,s=t._self._c||r;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h3",{attrs:{id:"_5种变量存储类"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_5种变量存储类"}},[t._v("#")]),t._v(" 5种变量存储类")]),t._v(" "),s("p",[s("img",{attrs:{src:_(498),alt:"cunChuLeiBianLiang"}})]),t._v(" "),s("ol",[s("li",[s("strong",[t._v("自动变量")]),t._v(" "),s("strong",[t._v("用auto")]),t._v(" 修饰或者不修饰就默认属于自动存储类的变量，具有自动存储周期、代码块作用域、空连接。在默认下，在代码快或者函数的头部定义的任意变量都属于自动存储类。初始化，除非手动初始化，否则不会被自动初始化。\n如果在内层中使用和外层一样名字的变量，则内层会覆盖外层变量，在程序离开内层代码块时，外部变量就恢复了其作用和之前的值。 对于自动变量，除非显式的初始化，否则不会自动初始化。")]),t._v(" "),s("li",[s("strong",[t._v("寄存器变量")]),t._v(" "),s("strong",[t._v("通过register")]),t._v(" 声明，放在寄存器而非内存中，所以无法获得其地址。注意，有时候虽然请求了把变量放于寄存器中，但是由于寄存器的个数，并不一定能满足，所以寄存器变量就成为了普通变量，不过依然不能对其取址。")]),t._v(" "),s("li",[s("strong",[t._v("具有外部链接的静态变量")]),t._v(" "),s("strong",[t._v("extern把变量的定义放在所有函数之外，")]),t._v(" 创建了一个外部变量。为了使程序更加清晰，可以在使用外部变量的函数中通过使用extern关键字来再次声明他，如果是在别的文件中声明的，那extern就是必须的。\n具有文件作用域、外部连接、静态时期（外部存储类，外部变量）。额外说明，外部变量只可进行一次初始化，而且在定义的时候。")]),t._v(" "),s("li",[s("strong",[t._v("具有内部链接的静态变量")]),t._v("\n这个与全局变量的区别在于声明时需要加上"),s("strong",[t._v("static")]),t._v(" 关键字,同时无法被其他文件使用.自动初始化为0.")]),t._v(" "),s("li",[s("strong",[t._v("具有代码块作用域的静态变量")]),t._v(" "),s("strong",[t._v("通过static修饰，如果不现实对其初始化，则自动初始化为0（提供了静态时期），在代码块内声明（提供了代码块作用域和空连接），")]),t._v(" 创建具有代码块作用域兼具静态存储的局部变量。这些变量具有代码块作用域，空连接，静态存储时期。变量一旦被定义便一直存在直到程序结束。\n"),s("strong",[t._v("注意：")]),t._v(" 对函数内的参量不能使用static定义。\n"),s("code",[t._v("int wotwork (static int flu)")]),t._v("\n这样表示为在函数内部，而不是内部连接")])]),t._v(" "),s("hr"),t._v(" "),s("h3",{attrs:{id:"_5种存储类说明符"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_5种存储类说明符"}},[t._v("#")]),t._v(" 5种存储类说明符")]),t._v(" "),s("p",[t._v("C语言中有5个作为存储类说明符的关键字,它们是"),s("strong",[t._v("auto,register,static,extern.typedef.")]),t._v("\n关键字typedef与内存存储无关,由于语法原因被归入此类.特别的,"),s("strong",[t._v("不可以在一个声明中使用一个以上存储类说明符")]),t._v(",这意味着不能将其他任一存储类说明符作为typedef的一部分.")]),t._v(" "),s("hr"),t._v(" "),s("h3",{attrs:{id:"_3种存储类型限定符"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3种存储类型限定符"}},[t._v("#")]),t._v(" 3种存储类型限定符")]),t._v(" "),s("p",[t._v("类型限定符可以用于指定被声明对象的特殊属性，可以与任何类型说明符一起使用。类型限定符有："),s("strong",[t._v("const、volatile和restrict")]),t._v("。")]),t._v(" "),s("ol",[s("li",[s("strong",[t._v("const用于声明可以存储在只读存储器中的对象")]),t._v("，并可能提高优化的可能性。可以对const对象进行初始化，但在"),s("strong",[t._v("初始化以后不能进行赋值")]),t._v("。")]),t._v(" "),s("li",[s("strong",[t._v("volatile用于强制某个实现屏蔽可能的优化")]),t._v("。例如，对于具有内存映像输入/输出的机器，指向设备寄存器的指针可以声明为指向volatile的指针，目的是防止编译器通过")]),t._v(" "),s("li",[s("strong",[t._v("由restrict修饰的指针是最初唯一对指针所指向的对象进行存取的方法")]),t._v("，仅当第二个指针基于第一个时，才能对对象进行存取。对对象的存取都限定于基于由restrict修饰的指针表达式中。 由restrict修饰的指针主要用于函数形参，或指向由malloc()分配的内存空间。restrict数据类型不改变程序的语义。编译器能通过作出restrict修饰的指针是存取对象的唯一方法的假设，更好地优化某些类型的例程。")])])])}),[],!1,null,null,null);r.default=v.exports}}]);